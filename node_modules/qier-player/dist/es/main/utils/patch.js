function isSameElement(a, b) {
    if (!a || !b)
        return false;
    return a === b || a.id === b.id;
}
function findSameElement(list, element) {
    return list.findIndex(function (item) { return item && isSameElement(item, element); });
}
export function patch(oldElements, newElements, container, op) {
    if (op === void 0) { op = {}; }
    var oldStartIdx = 0;
    var oldEndIdx = oldElements.length - 1;
    var newStartIdx = 0;
    var newEndIdx = newElements.length - 1;
    var oldStartEle = oldElements[oldStartIdx];
    var oldEndEle = oldElements[oldEndIdx];
    var newStartEle = newElements[newStartIdx];
    var newEndEle = newElements[newEndIdx];
    while (isSameElement(oldStartEle, newStartEle)) {
        oldStartEle = oldElements[++oldStartIdx];
        newStartEle = newElements[++newStartIdx];
    }
    while (isSameElement(oldEndEle, newEndEle)) {
        oldEndEle = oldElements[--oldEndIdx];
        newEndEle = newElements[--newEndIdx];
    }
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (oldStartEle === null) {
            oldStartEle = oldElements[++oldStartIdx];
        }
        else if (oldEndEle === null) {
            oldEndEle = oldElements[--oldEndIdx];
        }
        else if (newStartEle === null) {
            newStartEle = oldElements[++newStartIdx];
        }
        else if (newEndEle === null) {
            newEndEle = oldElements[--newEndIdx];
        }
        else if (isSameElement(oldStartEle, newStartEle)) {
            oldStartEle = oldElements[++oldStartIdx];
            newStartEle = newElements[++newStartIdx];
        }
        else if (isSameElement(oldStartEle, newEndEle)) {
            container.insertBefore(oldStartEle.el, oldEndEle.el);
            container.insertBefore(oldStartEle.el, oldEndEle.el.nextSibling);
            oldStartEle = oldElements[++oldStartIdx];
            newEndEle = newElements[--newEndIdx];
        }
        else if (isSameElement(oldEndEle, newStartEle)) {
            container.insertBefore(oldEndEle.el, oldStartEle.el);
            oldEndEle = oldElements[--oldEndIdx];
            newStartEle = newElements[++newStartIdx];
        }
        else if (isSameElement(oldEndEle, newEndEle)) {
            oldEndEle = oldElements[--oldEndIdx];
            newEndEle = newElements[--newEndIdx];
        }
        else {
            var findIndex = findSameElement(oldElements, newStartEle);
            if (findIndex === -1) {
                if (op.mount) {
                    op.mount(newStartEle);
                }
                container.insertBefore(newStartEle.el, oldStartEle.el);
            }
            else {
                var oldElement = oldElements[findIndex];
                container.insertBefore(oldElement.el, oldStartEle.el);
                oldElements[findIndex] = null;
            }
            newStartEle = newElements[++newStartIdx];
        }
    }
    if (oldStartIdx <= oldEndIdx) {
        for (var i = oldStartIdx; i <= oldEndIdx; i++) {
            if (op.unmount) {
                op.unmount(oldElements[i]);
            }
            oldElements[i] && container.removeChild(oldElements[i].el);
        }
    }
    else if (newStartIdx <= newEndIdx) {
        var before = newElements[newEndIdx + 1] ? newElements[newEndIdx + 1].el : null;
        for (var i = newStartIdx; i <= newEndIdx; i++) {
            if (op.mount) {
                op.mount(newElements[i]);
            }
            container.insertBefore(newElements[i].el, before);
        }
    }
}
//# sourceMappingURL=patch.js.map